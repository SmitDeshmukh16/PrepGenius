import os
import json
from google import genai
from dotenv import load_dotenv
import regex as re
from pydantic import BaseModel
from typing import Literal
from ..utils.tts import text_to_speech
from pprint import pprint
from google.genai import types
import sounddevice as sd
import scipy.io.wavfile as wav
load_dotenv()
import traceback
model = os.getenv("GEMINI_MODEL")


system_instruction="""
    Role: You are an AI Interview Bot conducting technical and HR interviews for Computer Science and IT candidates.
    Interview Guidelines:
    -Don't divert from the topic of the interview.
    -Ask both technical and HR questions, following up based on the candidate's responses.
    -Allow candidates to answer freely; if they struggle, guide them without giving direct answers.
    -Keep the conversation on-topic with smooth transitions between questions.
    -Ensure responses are clear and easy to pronounce for text-to-speech compatibility.
    """
class Evaluation(BaseModel):
    """
    Represents the evaluation of a candidate's answer.
    """
    transcription: str
    fluency_score: int
    fluency_feedback: str
    vocabulary_score: int
    vocabulary_feedback: str
    correctness_score: int
    correctness_feedback: str
    difficulty_level: Literal["Easy", "Medium", "Hard"]
    
class InterviewQuestion(BaseModel):
    """
    Represents an interview question generated by the AI bot.
    """
    question: str
    difficulty_level: Literal["Easy", "Medium", "Hard"]
    interview_done: bool


class CandidateInfo(BaseModel):
    name: str
    education: str
    skills: str
    position: str
    experience: str
    projects: str


class InterviewBot:
    def __init__(self, candidate_info: CandidateInfo):
        self.chat_history = []
        self.candidate_info = candidate_info
        self.client = genai.Client(api_key=os.getenv("Test_API_KEY"))
        self.evaluations = {}
        self.qno = 0
        self.current_question:InterviewQuestion = InterviewQuestion(
            question="",
            difficulty_level="Easy",
            interview_done=False
        )
        self.interview_done = False
        self.config = types.GenerateContentConfig(system_instruction=system_instruction,temperature=0.3,response_mime_type="application/json",response_schema=InterviewQuestion)
        self.chat_session = self.client.chats.create(model=model,config=self.config)

    def generate_prompt(self):
        return f"""
        Conduct an interview for the following candidate:
        - **Name**: {self.candidate_info.name}
        - **Education**: {self.candidate_info.education}
        - **Skills**: {self.candidate_info.skills}
        - **Experience**: {self.candidate_info.experience} 
        - **Projects**: {self.candidate_info.projects}
        - **Position**: {self.candidate_info.position}
        Respone:
        ```Json
        - "question":String
        - "difficulty_level":"Easy","Medium","Hard"
        - "interview_done":Bool
        ```
        Start with a technical question.
        """

    def response_formater(self, response):
        try:
            response_formatted = json.loads(response.text[response.text.find('```') + 7:response.text.rfind('```')])
            if not isinstance(response_formatted, dict):
                raise ValueError("Response is not in valid JSON format.")
            return response_formatted
        except (json.JSONDecodeError, ValueError) as e:
            pprint(f"Error parsing LLM response: {e}")
            return {"error": "Invalid JSON response from LLM"}

    def remove_pronunciations(self, text):
        try:
            return re.sub(r"\[(.*?)\]\(\/.*?\/\)", r"\1", text)
        except Exception as e:
            pprint(f"Error removing pronunciations: {e}")
            return text

    def start_interview(self):
        try:
            prompt = self.generate_prompt()
            response = self.chat_session.send_message(prompt)
            
            self.current_question = response.parsed
            pprint(response.parsed)
            

            
            
            question_text = str(self.current_question.question)
            difficulty = str(self.current_question.difficulty_level)
            file = str(text_to_speech(question_text))
            self.qno += 1
            pprint(question_text)

            return {
                "question": question_text,
                "difficulty_level": difficulty,
                "audio_file": file
            }
        except Exception as e:
            error_trace = traceback.format_exc()
            pprint(f"Error starting interview: {error_trace}")
            return {"error": "Failed to start interview"}

    def evaluate_answer_with_llm(self, question, answer_audio):
        try:
            with open(answer_audio, 'rb') as audio_file:
                audio_content = audio_file.read()
            evaluation_prompt = f"""
            The following is a question and a spoken answer. Please:
            1. Transcribe the audio.
            2. Evaluate the following response:
            
            **Question:** {question}
            
            **Fluency Analysis:**
            - Assess the fluency of the response.
            
            **Vocabulary Analysis:**
            - Assess lexical diversity and technical term usage.
            - Identify any excessive repetition.
            
            **Determine the difficulty level of the question (Easy, Medium, Hard) and assign the correctness score accordingly:**
            - Easy: Max score of 5
            - Medium: Max score of 7
            - Hard: Max score of 10
            
            """


            evaluation =self.client.models.generate_content(model=model, contents=[evaluation_prompt,types.Part.from_bytes(data=audio_content,mime_type="audio/wav")],config = types.GenerateContentConfig(temperature=0.2,response_mime_type="application/json",response_schema=Evaluation))
            evaluation = evaluation.parsed
            pprint(evaluation)
            self.evaluations[self.current_question.question] = evaluation.model_dump()
            return evaluation.transcription
        except Exception as e:
            pprint(f"Error evaluating answer: {e}")
            
    
    def answerandquestion(self, audio_file):
        try:
            # if audio_file:
            #     transcript = transcribe(audio_file)
            #     ans = " ".join([word[0] for word in transcript])
                
            # else:
            #     ans = text
            #     transcript = None

            # evaluation = self.evaluate_answer_with_llm(self.current_question, ans, transcript)
            # self.evaluations[self.current_question] = evaluation | {"answer": ans}

            # response = self.chat.send_message(ans)

            # # pprint(response)
            # response_formatted = self.response_formater(response)
            # file =text_to_speech(response_formatted['question'])
            # self.current_question = self.remove_pronunciations(response_formatted['question'])
            if audio_file:
                transcript = self.evaluate_answer_with_llm(self.current_question.question, audio_file)
                if transcript is None:
                    transcript = "No answer Provided"
                response = self.chat_session.send_message(transcript)
                self.current_question = response.parsed
                pprint(response.text.strip())
                
            file = text_to_speech(self.current_question.question)
            self.qno += 1
            return{
                "question": self.current_question.question,
                "difficulty_level": self.current_question.difficulty_level,
                "audio_file": file,
                "interview_done": self.current_question.interview_done
            }
        except Exception as e:
            error_trace = traceback.format_exc()
            pprint(f"Error in processing answer and question: {error_trace}")
            return {"error": "Failed to process answer"}
    def exit_interview(self):
      
        return {"interview_done": self.interview_done,"evaluations":self.evaluations}
        

    
DURATION = 10  # seconds
SAMPLE_RATE = 16000
FILENAME = "answer.wav"

def record_audio(filename=FILENAME, duration=DURATION, samplerate=SAMPLE_RATE):
    print(f"Recording for {duration} seconds...")
    audio = sd.rec(int(duration * samplerate), samplerate=samplerate, channels=1, dtype='int16')
    sd.wait()
    wav.write(filename, samplerate, audio)
    print(f"Recording saved to {filename}")
    return filename

if __name__ == "__main__":
    # Step 1: Create candidate info
    candidate = CandidateInfo(
        name="Smit Deshmukh",
        education="B.Tech in Computer Science",
        skills="Python, Machine Learning, Django",
        position="Software Engineer",
        experience="2 years",
        projects="AI-based Interview Bot, Chatbot with RAG"
    )
    bot = InterviewBot(candidate_info=candidate)
    response = bot.start_interview()
    pprint(response)
    while True:
        user = record_audio()
        response = bot.answerandquestion("answer.wav")
        pprint(response)
        if response["interview_done"]:
            break

    response = bot.exit_interview()
    pprint(response)

    